# UUID 的结构和含义

通常看到的 UUID 像下面这样：

```
550e8400-e29b-41d4-a716-446655440000
```

其中的一堆字符有含义吗？

## UUID 是什么

UUID 的全称为"Universally Unique ID"，即"通用唯一标识符"。UUID 是[国际标准化组织](https://baike.baidu.com/item/%E5%9B%BD%E9%99%85%E6%A0%87%E5%87%86%E5%8C%96%E7%BB%84%E7%BB%87/779832?fromModule=lemma_inlink)（[ISO](https://baike.baidu.com/item/ISO/10400?fromModule=lemma_inlink)）提出的一个概念。

其目的是通过计算生成一个在所有空间和时间上被视为唯一的标识。因此，最开始的 UUID 的计算是基于以下信息：
- 空间：设备的硬件标识，通常是设备的 MAC 地址、网卡的 MAC 地址或其他的什么地址。
- 时间：当前的时间、时钟序列

UUID 最重要的特征就是随机唯一性，所以可以用来作为：唯一标识（不泄露隐私）、随机密钥等。

> 身份证号可以作为人的唯一标识，但是其内容暴露了个人隐私信息（地区、生日）。

## UUID 的结构

UUID 的长度为 128bit，一般表示为 32 位十六进制字符，中间被 4 个连字符分隔为 5 个部分，所以 UUID 的长度为 36 个字符。其中 5 个部分的长度分别为 8-4-4-4-12，即：

```
xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
```


## UUID 的含义

问题：当遇到一个 UUID，可以从中看出什么信息吗，它的组成有规律吗，可以理解它吗？
答案：可能可以。

因为 UUID 有多个版本，每个版本的计算和组成方式都不同。所以只需要知道它是哪一个版本，就能套模板知道每个部分的子串的含义，但是有的版本就完全是随机数，所以没有任何含义。

UUID 的各个版本之间的主要区别如下表所示：

| 版本 | 生成方式                        | 特点                          | 适用场景                                 | 备注                                         |
| ---- | ------------------------------- | ----------------------------- | ---------------------------------------- | -------------------------------------------- |
| 1    | 时间戳 + 时钟序列 + MAC地址     | 可预测，可能暴露MAC地址       | 分布式系统中需要时间顺序的场合           | 存在重复几率，根据ID能推算出创建时的相对时间 |
| 2    | 基于时间戳和DCE安全ID           | 暴露用户信息，使用受限        | 需要安全ID的分布式系统                   | 应用较少，有隐私风险                         |
| 3    | MD5散列值（名字空间ID + 名称）  | 命名空间+名称生成，保证唯一性 | 需要根据特定值生成UUID的场合             | 保证相同名字空间中不同名字生成的UUID的唯一性 |
| 4    | 完全随机的数据                  | 高随机性，不可预测            | 需要完全随机UUID的场合                   | 良好的随机性和隐私保护，最常用               |
| 5    | SHA1散列值（名字空间ID + 名称） | 命名空间+名称生成，更强安全性 | 需要根据特定值生成UUID且要求安全性的场合 | 使用SHA1代替MD5，增强安全性                  |

从表格中可以看出，UUID版本1和2依赖于时间戳和硬件地址，可能会暴露隐私信息，而版本3和5基于散列算法生成，保证了相同输入生成相同UUID的能力。版本4则完全基于随机数生成，适用于大多数需要高随机性和隐私保护的场合。不同版本的UUID适用于不同的应用场景，选择时需要根据具体需求来决定使用哪个版本。

**到此为止，就可以知道 UUID 是啥了，以及从它并看不出来啥东西，因为可能某个字符被改过，如果你实在想知道如何理解一个标准的 UUID，可以继续往下看。**

标准的 UUID 的版本号的位置是固定的，即第三组的第一个字符表示的就是版本号的值。例如：

```
550e8400-e29b-41d4-a716-446655440000
```

可以看到第三组的第一个字符是 4，所以版本号为 4，再去套该版本的官方解释，就知道其中子串的含义了。

> 注意：相同版本号的 UUID 布局也不一定相同，因为第四组的高三位表示“变体”（不同的布局）：
> - 变体0：前两位为`00`（保留，用于向后兼容）
> - 变体1：前两位为`10`（最常用的变体）
> - 变体2：前两位为`110`（用于DCE安全UUID）
> - 变体3：前三位为`111`（保留，用于将来的定义
> 
> 每个版本含义不同，但均遵循 8-4-4-4-12 的格式，其中版本号和变体号的位置是固定的。


下面以版本 1 的 UUID 为例，解释各个部分：

```
550e8400-e29b-11d4-a716-446655440000
```

- **550e8400**：`time_low`，表示从 UUID 的时间基准开始经过的 100 纳秒时间间隔的低 32 位。
- **e29b**：`time_mid`，表示时间戳的中间 16 位。
- **11d4**：`time_hi_and_version`，时间戳的高位字段和 UUID 版本号，高 4 位用于表示 UUID 的版本号（对于版本 1，值为 1），其余 12 位表示时间戳的高位。
- **a716**：`clock_seq_hi_and_reserved` 和 `clock_seq_low`，高 2 位用于表示 UUID 的变体（Variant），确定 UUID 的布局。其余 14 位表示时钟序列，用于避免在时间倒退时产生重复的 UUID。
- **446655440000**：`node`，通常使用设备的 MAC 地址，确保空间上的唯一性。